/*****************************************************************************************/
/* SCALE3X                                                                               */
/*****************************************************************************************/
{
	// vertex shader
	"struct VsOutput {\n"
	"	float4 Position : POSITION;\n"
	"	float2 TexCoord : TEXCOORD0;\n"
	"};\n"

	"float4x4 m_world_view_projection : WORLDVIEWPROJECTION;\n"

	"VsOutput Vs(float4 position : POSITION, float2 texCoord : TEXCOORD0) {\n"
	"	VsOutput output;\n"
	"	output.Position = mul(position, m_world_view_projection);\n"
	"	output.TexCoord = texCoord;\n"
	"	return output;\n"
	"}",
	// pixel shader
	"float2 size_screen_emu;\n"
	"float2 size_video_mode;\n"
	"float2 size_texture;\n"

	"texture texture_scr;\n"
	"sampler2D s0 = sampler_state { Texture = <texture_scr>; };\n"

	"float2 fract(float2 x) {\n"
	"	return x - floor(x);\n"
	"}\n"

	"float4 Ps(float2 texCoord : TEXCOORD0) : COLOR {\n"
	"	float2 dx = float2((1.0 / size_texture.x), 1.0);\n"
	"	float2 dy = float2(0.0, (1.0 / size_texture.y));\n"

	"	float4 v_texCoord[5];\n"

	"	v_texCoord[0]    = float4(texCoord, 0.0, 0.0); // E\n"
	"	v_texCoord[0].zw = v_texCoord[0].xy - dx - dy; // A\n"
	"	v_texCoord[1].xy = v_texCoord[0].xy - dy;      // B\n"
	"	v_texCoord[1].zw = v_texCoord[0].xy + dx - dy; // C\n"
	"	v_texCoord[2].xy = v_texCoord[0].xy - dx;      // D\n"
	"	v_texCoord[2].zw = v_texCoord[0].xy + dx;      // F\n"
	"	v_texCoord[3].xy = v_texCoord[0].xy - dx + dy; // G\n"
	"	v_texCoord[3].zw = v_texCoord[0].xy + dy;      // H\n"
	"	v_texCoord[4].xy = v_texCoord[0].xy + dx + dy; // I\n"

	"	// sufficient precision for HDTV (1920x1080)\n"
	"	const float2 sep = float2(0.33333, 0.66667);\n"

	"	float4 E = tex2D(s0, v_texCoord[0].xy); // E\n"
	"	float4 A = tex2D(s0, v_texCoord[0].zw); // A\n"
	"	float4 B = tex2D(s0, v_texCoord[1].xy); // B\n"
	"	float4 C = tex2D(s0, v_texCoord[1].zw); // C\n"
	"	float4 D = tex2D(s0, v_texCoord[2].xy); // D\n"
	"	float4 F = tex2D(s0, v_texCoord[2].zw); // F\n"
	"	float4 G = tex2D(s0, v_texCoord[3].xy); // G\n"
	"	float4 H = tex2D(s0, v_texCoord[3].zw); // H\n"
	"	float4 I = tex2D(s0, v_texCoord[4].xy); // I\n"
	"	// to be sure that ((E != A) == true) in function call\n"
	"	float4 X = float4(1.0, 1.0, 1.0, 1.0) - E;\n"
	"	float4 T;\n"

	"	float2 sel = fract(v_texCoord[0].xy * size_texture);// where are we (E0-E8)?\n"
	"	// branching is very undesirable, so we make a lot of reassignments\n"
	"	// of original pixels to make sure that rule for E1 pixel will work\n"
	"	// with any other (rotate second matrix and swap some Ex)\n"

	"	// native function call --> x y --> equivalent transpose (to minimize reassignments)\n"
	"	//(E, B, X, D, E, F, H) --> 0 0 --> (E, B, X, D, E, F, H) for E0\n"
	"	//(A, B, C, D, E, F, H) --> 1 0 --> (A, B, C, D, E, F, H) for E1\n"
	"	//(E, F, X, B, E, H, D) --> 2 0 --> (X, F, E, D, E, B, H) for E2\n"
	"	//(G, D, A, H, E, B, F) --> 0 1 --> (A, D, G, B, E, H, F) for E3\n"
	"	//( , E,  ,  , E,  ,  ) --> 1 1 --> ( , E,  ,  , E,  ,  ) for E4\n"
	"	//(C, F, I, B, E, H, D) --> 2 1 --> (I, F, C, H, E, B, D) for E5\n"
	"	//(E, D, X, H, E, B, F) --> 0 2 --> (E, D, X, H, E, F, B) for E6\n"
	"	//(I, H, G, F, E, D, B) --> 1 2 --> (G, H, I, D, E, F, B) for E7\n"
	"	//(E, H, X, F, E, D, B) --> 2 2 --> (X, H, E, D, E, F, B) for E8\n"
	"	if (sel.y < sep.x) {\n"
	"		if (sel.x < sep.x) {\n"
	"			A = E;\n"
	"			C = X;\n"
	"		} else if (sel.x >= sep.y) {\n"
	"			A = X;\n"
	"			C = E;\n"
	"			T = B;\n"
	"			B = F;\n"
	"			F = T;\n"
	"		}\n"
	"	} else if (sel.y < sep.y) {\n"
	"		T = B;\n"
	"		if (sel.x < sep.x) {\n"
	"			B = D;\n"
	"			D = T;\n"
	"			C = G;\n"
	"			T = F;\n"
	"			F = H;\n"
	"		} else if (sel.x < sep.y) {\n"
	"			B = E;\n"
	"		} else {\n"
	"			A = I;\n"
	"			B = F;\n"
	"			F = T;\n"
	"			T = D;\n"
	"			D = H;\n"
	"		}\n"
	"		H = T;\n"
	"	} else {\n"
	"		T = B;\n"
	"		if (sel.x < sep.x) {\n"
	"			A = E;\n"
	"			C = X;\n"
	"			B = D;\n"
	"			D = H;\n"
	"		} else {\n"
	"			if (sel.x < sep.y) {\n"
	"				A = G;\n"
	"				C = I;\n"
	"			} else {\n"
	"				A = X;\n"
	"				C = E;\n"
	"			}\n"
	"			B = H;\n"
	"		}\n"
	"		H = T;\n"
	"	}\n"

	"	float4 scr = ((D == B && B != F && D != H && E != C) ||"
	"			(B == F && B != D && F != H && E != A)) ?"
	"			B : E; // Scale3x rule\n"

	"	return scr;\n"
	"}",
},
