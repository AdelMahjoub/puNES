{
"#define FXAA_REDUCE_MIN (1.0/256.0)\n"
"#define FXAA_REDUCE_MUL (1.0/8.0)\n"
"#define FXAA_SPAN_MAX 8.0\n"
"#define FXAA_SUBPIX_SHIFT (1.0/8.0)\n"
"struct input\n"
"{\n"
"  float2 video_size;\n"
"  float2 texture_size;\n"
"  float2 output_size;\n"
"  float frame_count;\n"
"  float frame_direction;\n"
"  float frame_rotation;\n"
"};\n"
"\n"
"struct VERTEX_OUTPUT {\n"
"  float4 position : POSITION;\n"
"  float4 vpos : TEXCOORD1;\n"
"  float2 texCoord : TEXCOORD0;\n"
"};\n"
"\n"
"struct output \n"
"{\n"
"  float4 color : COLOR;\n"
"};\n"
"\n"
"VERTEX_OUTPUT main_vertex\n"
"(\n"
"	float4 position	: POSITION,\n"
"	float2 texCoord : TEXCOORD0,\n"
"	float4 vpos : TEXCOORD1,\n"
"    uniform input IN,\n"
"   	uniform float4x4 modelViewProj\n"
")\n"
"{\n"
"	VERTEX_OUTPUT OUT;\n"
"	OUT.position = mul(modelViewProj, position);\n"
"    OUT.vpos = OUT.position;\n"
"	OUT.texCoord = texCoord;\n"
"	return OUT;\n"
"}\n"
"\n"
"\n"
"output main_fragment(in VERTEX_OUTPUT VAR, uniform sampler2D decal : TEXUNIT0, uniform input IN) \n"
"{\n"
"    //yes Cg is THIS retarded, passing position as texturecoord\n"
"	output OUT;\n"
"	VAR.vpos /= VAR.vpos.w;\n"
"	\n"
"	float2 inverse_resolution=1/IN.video_size.xy;\n"
"	float4 coords;\n"
"	coords.xy = VAR.texCoord;\n"
"	coords.zw = coords.xy - (inverse_resolution.xy * (0.5 + FXAA_SUBPIX_SHIFT));\n"
"    float3 rgbNW = tex2D(decal, (VAR.texCoord + float2(-1.0,-1.0)) * inverse_resolution).xyz;\n"
"    float3 rgbNE = tex2D(decal, (VAR.texCoord + float2(1.0,-1.0)) * inverse_resolution).xyz;\n"
"    float3 rgbSW = tex2D(decal, (VAR.texCoord + float2(-1.0,1.0)) * inverse_resolution).xyz;\n"
"    float3 rgbSE = tex2D(decal, (VAR.texCoord + float2(1.0,1.0)) * inverse_resolution).xyz;\n"
"    float3  rgbM  = tex2D(decal,  VAR.texCoord ).xyz;\n"
"    float3  luma = vec3(0.299, 0.587, 0.114);\n"
"	float lumaNW = dot(rgbNW, luma);\n"
"	float lumaNE = dot(rgbNE, luma);\n"
"	float lumaSW = dot(rgbSW, luma);\n"
"	float lumaSE = dot(rgbSE, luma);\n"
"	float lumaM  = dot(rgbM,  luma);\n"
"	float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n"
"	float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE))); \n"
"	float2 dir;\n"
"    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n"
"    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n"
"	float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),FXAA_REDUCE_MIN);\n"
"	float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n"
"	dir = min(float2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),max(float2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),dir * rcpDirMin)) * inverse_resolution;\n"
"	\n"
"	float3 rgbA = 0.5 * (tex2D(decal,   VAR.texCoord + dir * (1.0/3.0 - 0.5)).xyz + \n"
"	tex2D(decal,   VAR.texCoord  + dir * (2.0/3.0 - 0.5)).xyz);\n"
"    float3 rgbB = rgbA * 0.5 + 0.25 * (tex2D(decal,  VAR.texCoord  * inverse_resolution + dir *  - 0.5).xyz \n"
"	+ tex2D(decal,  VAR.texCoord + dir * 0.5).xyz);\n"
"	float lumaB = dot(rgbB, luma);\n"
"	if((lumaB < lumaMin) || (lumaB > lumaMax)) {\n"
"      OUT.color = float4(rgbA,1.0);\n"
"	} else {\n"
"      OUT.color = float4(rgbB,1.0);\n"
"	}\n"
"\n"
"	return OUT;\n"
"	\n"
"}\n"
},
