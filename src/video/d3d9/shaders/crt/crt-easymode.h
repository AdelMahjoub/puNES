{
"/*\n"
"    CRT Shader by EasyMode\n"
"    License: GPL\n"
"\n"
"    A flat CRT shader ideally for 1080p or higher displays.\n"
"\n"
"    Recommended Settings:\n"
"\n"
"    Video\n"
"    - Aspect Ratio: 4:3\n"
"    - Integer Scale: Off\n"
"\n"
"    Shader\n"
"    - Filter: Nearest\n"
"    - Scale: Don't Care\n"
"\n"
"    Example RGB Mask Parameter Settings:\n"
"\n"
"    Aperture Grille (Default)\n"
"    - Dot Width: 1\n"
"    - Dot Height: 1\n"
"    - Stagger: 0\n"
"\n"
"    Lottes' Shadow Mask\n"
"    - Dot Width: 2\n"
"    - Dot Height: 1\n"
"    - Stagger: 3\n"
"*/\n"
"\n"
"#pragma parameter SHARPNESS_H \"Sharpness Horizontal\" 0.5 0.0 1.0 0.05\n"
"#pragma parameter SHARPNESS_V \"Sharpness Vertical\" 1.0 0.0 1.0 0.05\n"
"#pragma parameter MASK_STRENGTH \"Mask Strength\" 0.3 0.0 1.0 0.01\n"
"#pragma parameter MASK_DOT_WIDTH \"Mask Dot Width\" 1.0 1.0 100.0 1.0\n"
"#pragma parameter MASK_DOT_HEIGHT \"Mask Dot Height\" 1.0 1.0 100.0 1.0\n"
"#pragma parameter MASK_STAGGER \"Mask Stagger\" 0.0 0.0 100.0 1.0\n"
"#pragma parameter MASK_SIZE \"Mask Size\" 1.0 1.0 100.0 1.0\n"
"#pragma parameter SCANLINE_STRENGTH \"Scanline Strength\" 1.0 0.0 1.0 0.05\n"
"#pragma parameter SCANLINE_BEAM_WIDTH_MIN \"Scanline Beam Width Min.\" 1.5 0.5 5.0 0.5\n"
"#pragma parameter SCANLINE_BEAM_WIDTH_MAX \"Scanline Beam Width Max.\" 1.5 0.5 5.0 0.5\n"
"#pragma parameter SCANLINE_BRIGHT_MIN \"Scanline Brightness Min.\" 0.35 0.0 1.0 0.05\n"
"#pragma parameter SCANLINE_BRIGHT_MAX \"Scanline Brightness Max.\" 0.65 0.0 1.0 0.05\n"
"#pragma parameter SCANLINE_CUTOFF \"Scanline Cutoff\" 400.0 1.0 1000.0 1.0\n"
"#pragma parameter GAMMA_INPUT \"Gamma Input\" 2.0 0.1 5.0 0.1\n"
"#pragma parameter GAMMA_OUTPUT \"Gamma Output\" 1.8 0.1 5.0 0.1\n"
"#pragma parameter BRIGHT_BOOST \"Brightness Boost\" 1.2 1.0 2.0 0.01\n"
"#pragma parameter DILATION \"Dilation\" 1.0 0.0 1.0 1.0\n"
"\n"
"#ifdef PARAMETER_UNIFORM\n"
"uniform float BRIGHT_BOOST;\n"
"uniform float DILATION;\n"
"uniform float GAMMA_INPUT;\n"
"uniform float GAMMA_OUTPUT;\n"
"uniform float MASK_SIZE;\n"
"uniform float MASK_STAGGER;\n"
"uniform float MASK_STRENGTH;\n"
"uniform float MASK_DOT_HEIGHT;\n"
"uniform float MASK_DOT_WIDTH;\n"
"uniform float SCANLINE_CUTOFF;\n"
"uniform float SCANLINE_BEAM_WIDTH_MAX;\n"
"uniform float SCANLINE_BEAM_WIDTH_MIN;\n"
"uniform float SCANLINE_BRIGHT_MAX;\n"
"uniform float SCANLINE_BRIGHT_MIN;\n"
"uniform float SCANLINE_STRENGTH;\n"
"uniform float SHARPNESS_H;\n"
"uniform float SHARPNESS_V;\n"
"#else\n"
"#define BRIGHT_BOOST 1.2\n"
"#define DILATION 1.0\n"
"#define GAMMA_INPUT 2.0\n"
"#define GAMMA_OUTPUT 1.8\n"
"#define MASK_SIZE 1.0\n"
"#define MASK_STAGGER 0.0\n"
"#define MASK_STRENGTH 0.3\n"
"#define MASK_DOT_HEIGHT 1.0\n"
"#define MASK_DOT_WIDTH 1.0\n"
"#define SCANLINE_BEAM_WIDTH_MAX 1.5\n"
"#define SCANLINE_BEAM_WIDTH_MIN 1.5\n"
"#define SCANLINE_BRIGHT_MAX 0.65\n"
"#define SCANLINE_BRIGHT_MIN 0.35\n"
"#define SCANLINE_CUTOFF 400.0\n"
"#define SCANLINE_STRENGTH 1.0\n"
"#define SHARPNESS_H 0.5\n"
"#define SHARPNESS_V 1.0\n"
"#endif\n"
"\n"
"#define FIX(c) max(abs(c), 1e-5)\n"
"#define PI 3.141592653589\n"
"#define TEX2D(c) dilate(tex2D(tex, c))\n"
"\n"
"// Set to 0 to use linear filter and gain speed\n"
"#define ENABLE_LANCZOS 1\n"
"\n"
"void main_vertex\n"
"(\n"
"    float4 position : POSITION,\n"
"    out float4 oPosition : POSITION,\n"
"    uniform float4x4 modelViewProj,\n"
"\n"
"    float2 tex : TEXCOORD,\n"
"    out float2 oTex : TEXCOORD\n"
")\n"
"{\n"
"    oPosition = mul(modelViewProj, position);\n"
"    oTex = tex;\n"
"}\n"
"\n"
"struct input\n"
"{\n"
"    float2 video_size;\n"
"    float2 texture_size;\n"
"    float2 output_size;\n"
"    float frame_count;\n"
"    float frame_direction;\n"
"    float frame_rotation;\n"
"};\n"
"\n"
"float4 dilate(float4 col)\n"
"{\n"
"    float4 x = lerp(float4(1.0), col, DILATION);\n"
"\n"
"    return col * x;\n"
"}\n"
"\n"
"float curve_distance(float x, float sharp)\n"
"{\n"
"\n"
"/*\n"
"    apply half-circle s-curve to distance for sharper (more pixelated) interpolation\n"
"    single line formula for Graph Toy:\n"
"    0.5 - sqrt(0.25 - (x - step(0.5, x)) * (x - step(0.5, x))) * sign(0.5 - x)\n"
"*/\n"
"\n"
"    float x_step = step(0.5, x);\n"
"    float curve = 0.5 - sqrt(0.25 - (x - x_step) * (x - x_step)) * sign(0.5 - x);\n"
"\n"
"    return lerp(x, curve, sharp);\n"
"}\n"
"\n"
"float4x4 get_color_matrix(sampler2D tex, float2 co, float2 dx)\n"
"{\n"
"    return float4x4(TEX2D(co - dx), TEX2D(co), TEX2D(co + dx), TEX2D(co + 2.0 * dx));\n"
"}\n"
"\n"
"float3 filter_lanczos(float4 coeffs, float4x4 color_matrix)\n"
"{\n"
"    float4 col = mul(coeffs, color_matrix);\n"
"    float4 sample_min = min(color_matrix[1], color_matrix[2]);\n"
"    float4 sample_max = max(color_matrix[1], color_matrix[2]);\n"
"\n"
"    col = clamp(col, sample_min, sample_max);\n"
"\n"
"    return col.rgb;\n"
"}\n"
"\n"
"float4 main_fragment(uniform sampler2D tex : TEXUNIT0, float2 coords : TEXCOORD0, uniform input IN) : COLOR\n"
"{\n"
"    float2 dx = float2(1.0 / IN.texture_size.x, 0.0);\n"
"    float2 dy = float2(0.0, 1.0 / IN.texture_size.y);\n"
"    float2 pix_co = coords * IN.texture_size - float2(0.5, 0.5);\n"
"    float2 tex_co = (floor(pix_co) + float2(0.5, 0.5)) / IN.texture_size;\n"
"    float2 dist = frac(pix_co);\n"
"    float curve_x;\n"
"    float3 col, col2;\n"
"\n"
"#if ENABLE_LANCZOS\n"
"    curve_x = curve_distance(dist.x, SHARPNESS_H * SHARPNESS_H);\n"
"\n"
"    float4 coeffs = PI * float4(1.0 + curve_x, curve_x, 1.0 - curve_x, 2.0 - curve_x);\n"
"\n"
"    coeffs = FIX(coeffs);\n"
"    coeffs = 2.0 * sin(coeffs) * sin(coeffs / 2.0) / (coeffs * coeffs);\n"
"    coeffs /= dot(coeffs, float4(1.0));\n"
"\n"
"    col = filter_lanczos(coeffs, get_color_matrix(tex, tex_co, dx));\n"
"    col2 = filter_lanczos(coeffs, get_color_matrix(tex, tex_co + dy, dx));\n"
"#else\n"
"    curve_x = curve_distance(dist.x, SHARPNESS_H);\n"
"\n"
"    col = lerp(TEX2D(tex_co).rgb, TEX2D(tex_co + dx).rgb, curve_x);\n"
"    col2 = lerp(TEX2D(tex_co + dy).rgb, TEX2D(tex_co + dx + dy).rgb, curve_x);\n"
"#endif\n"
"\n"
"    col = lerp(col, col2, curve_distance(dist.y, SHARPNESS_V));\n"
"    col = pow(col, float3(GAMMA_INPUT / (DILATION + 1.0)));\n"
"\n"
"    float luma = dot(float3(0.2126, 0.7152, 0.0722), col);\n"
"    float bright = (max(col.r, max(col.g, col.b)) + luma) / 2.0;\n"
"    float scan_bright = clamp(bright, SCANLINE_BRIGHT_MIN, SCANLINE_BRIGHT_MAX);\n"
"    float scan_beam = clamp(bright * SCANLINE_BEAM_WIDTH_MAX, SCANLINE_BEAM_WIDTH_MIN, SCANLINE_BEAM_WIDTH_MAX);\n"
"    float scan_weight = 1.0 - pow(cos(coords.y * 2.0 * PI * IN.texture_size.y) * 0.5 + 0.5, scan_beam) * SCANLINE_STRENGTH;\n"
"\n"
"    float mask = 1.0 - MASK_STRENGTH;    \n"
"    float2 mod_fac = floor(coords * IN.output_size * IN.texture_size / (IN.video_size * float2(MASK_SIZE, MASK_DOT_HEIGHT * MASK_SIZE)));\n"
"    int dot_no = int(mod((mod_fac.x + mod(mod_fac.y, 2.0) * MASK_STAGGER) / MASK_DOT_WIDTH, 3.0));\n"
"    float3 mask_weight;\n"
"\n"
"    if (dot_no == 0) mask_weight = float3(1.0, mask, mask);\n"
"    else if (dot_no == 1) mask_weight = float3(mask, 1.0, mask);\n"
"    else mask_weight = float3(mask, mask, 1.0);\n"
"\n"
"    if (IN.video_size.y >= SCANLINE_CUTOFF) scan_weight = 1.0;\n"
"\n"
"    col2 = col.rgb;\n"
"    col *= float3(scan_weight);\n"
"    col = lerp(col, col2, scan_bright);\n"
"    col *= mask_weight;\n"
"    col = pow(col, float3(1.0 / GAMMA_OUTPUT));\n"
"\n"
"    return float4(col * BRIGHT_BOOST, 1.0);\n"
"}\n"
},
