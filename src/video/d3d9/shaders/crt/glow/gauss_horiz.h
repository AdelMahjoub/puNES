{
"struct data\n"
"{\n"
"   float2 tex;\n"
"   float pix_no;\n"
"   float one;\n"
"};\n"
"\n"
"struct input\n"
"{\n"
"   float2 video_size;\n"
"   float2 texture_size;\n"
"   float2 output_size;\n"
"};\n"
"\n"
"void main_vertex\n"
"(\n"
"   float4 position : POSITION,\n"
"   out float4 oPosition : POSITION,\n"
"   uniform float4x4 modelViewProj,\n"
"   float2 tex : TEXCOORD,\n"
"   uniform input IN,\n"
"   out data oData\n"
")\n"
"{\n"
"   oPosition = mul(modelViewProj, position);\n"
"   oData.tex = tex;\n"
"   oData.pix_no = tex.x * IN.texture_size.x;\n"
"   oData.one = 1.0 / IN.texture_size.x;\n"
"}\n"
"\n"
"#define INV_SQRT_2_PI 0.38 // Doesn't have to be accurate.\n"
"\n"
"#pragma parameter HORIZ_GAUSS_WIDTH \"Gaussian Width\" 0.5 0.4 0.6 0.02\n"
"#ifdef PARAMETER_UNIFORM\n"
"uniform float HORIZ_GAUSS_WIDTH;\n"
"#else\n"
"#define HORIZ_GAUSS_WIDTH 0.5\n"
"#endif\n"
"\n"
"float4 main_fragment (uniform input IN, in data vertex, uniform sampler2D s0 : TEXUNIT0) : COLOR\n"
"{\n"
"#define TEX(off_x) tex2D(s0, tex + float2(float(off_x) * vertex.one, 0.0)).rgb\n"
"\n"
"   float texel = floor(vertex.pix_no);\n"
"   float phase = vertex.pix_no - texel;\n"
"   float base_phase = phase.x - 0.5;\n"
"   float2 tex = float2((texel + 0.5) / IN.texture_size.x, vertex.tex.y);\n"
"\n"
"   float3 col = float3(0.0);\n"
"   for (int i = -2; i <= 2; i++)\n"
"   {\n"
"      float phase = base_phase - float(i);\n"
"      float g = INV_SQRT_2_PI * exp(-0.5 * phase * phase / (HORIZ_GAUSS_WIDTH * HORIZ_GAUSS_WIDTH)) / HORIZ_GAUSS_WIDTH;\n"
"      col += TEX(i) * g;\n"
"   }\n"
"\n"
"   return float4(col, 1.0);\n"
"}\n"
"\n"
},
