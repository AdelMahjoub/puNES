{
"/* COMPATIBILITY \n"
"   - HLSL compilers\n"
"   - Cg   compilers\n"
"*/\n"
"\n"
"\n"
"/*\n"
"* Copyright (C) 2003 Maxim Stepin ( maxst@hiend3d.com )\n"
"*\n"
"* Copyright (C) 2010 Cameron Zemek ( grom@zeminvaders.net )\n"
"*\n"
"* Copyright (C) 2014 Jules Blok ( jules@aerix.nl )\n"
"*\n"
"* This program is free software; you can redistribute it and/or\n"
"* modify it under the terms of the GNU Lesser General Public\n"
"* License as published by the Free Software Foundation; either\n"
"* version 2.1 of the License, or (at your option) any later version.\n"
"*\n"
"* This program is distributed in the hope that it will be useful,\n"
"* but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n"
"* Lesser General Public License for more details.\n"
"*\n"
"* You should have received a copy of the GNU Lesser General Public\n"
"* License along with this program; if not, write to the Free Software\n"
"* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n"
"*/\n"
"\n"
"#pragma parameter trY \"Y Threshold\" 48.0 0.0 255.0 1.0\n"
"#pragma parameter trU \"U Threshold\" 7.0 0.0 255.0 1.0\n"
"#pragma parameter trV \"V Threshold\" 6.0 0.0 255.0 1.0\n"
"\n"
"#ifdef PARAMETER_UNIFORM\n"
"uniform float trY;\n"
"uniform float trU;\n"
"uniform float trV;\n"
"#else\n"
"#define trY 48.0\n"
"#define trU 7.0\n"
"#define trV 6.0\n"
"#endif\n"
"\n"
"static half3 yuv_threshold = half3(trY/255.0, trU/255.0, trV/255.0);\n"
"\n"
"const static half3x3 yuv = half3x3(0.299, 0.587, 0.114, -0.169, -0.331, 0.5, 0.5, -0.419, -0.081);\n"
"const static half3 yuv_offset = half3(0, 0.5, 0.5);\n"
"\n"
"bool diff(float3 yuv1, float3 yuv2) {\n"
"	bool3 res = abs((yuv1 + yuv_offset) - (yuv2 + yuv_offset)) > yuv_threshold;\n"
"	return res.x || res.y || res.z;\n"
"}\n"
"\n"
"struct input\n"
"{\n"
"	half2 video_size;\n"
"	float2 texture_size;\n"
"	half2 output_size;\n"
"};\n"
"\n"
"struct out_vertex {\n"
"	float4 position : POSITION;\n"
"	float4 color    : COLOR;\n"
"	float2 texCoord : TEXCOORD0;\n"
"	float4 t1       : TEXCOORD1;\n"
"	float4 t2       : TEXCOORD2;\n"
"	float4 t3       : TEXCOORD3;\n"
"};\n"
"\n"
"/*    VERTEX_SHADER    */\n"
"out_vertex main_vertex\n"
"(\n"
"	float4 position	: POSITION,\n"
"	float4 color	: COLOR,\n"
"	float2 texCoord : TEXCOORD0,\n"
"\n"
"   	uniform half4x4 modelViewProj,\n"
"	uniform input IN\n"
")\n"
"{\n"
"	out_vertex OUT;\n"
"\n"
"	OUT.position = mul(modelViewProj, position);\n"
"	OUT.color = color;\n"
"\n"
"	float2 ps = 1.0/IN.texture_size;\n"
"	float dx = ps.x;\n"
"	float dy = ps.y;\n"
"\n"
"	//   +----+----+----+\n"
"	//   |    |    |    |\n"
"	//   | w1 | w2 | w3 |\n"
"	//   +----+----+----+\n"
"	//   |    |    |    |\n"
"	//   | w4 | w5 | w6 |\n"
"	//   +----+----+----+\n"
"	//   |    |    |    |\n"
"	//   | w7 | w8 | w9 |\n"
"	//   +----+----+----+\n"
"\n"
"	OUT.texCoord = texCoord;\n"
"	OUT.t1 = texCoord.xxxy + half4(-dx, 0, dx, -dy); //  w1 | w2 | w3\n"
"	OUT.t2 = texCoord.xxxy + half4(-dx, 0, dx,   0); //  w4 | w5 | w6\n"
"	OUT.t3 = texCoord.xxxy + half4(-dx, 0, dx,  dy); //  w7 | w8 | w9\n"
"\n"
"	return OUT;\n"
"}\n"
"\n"
"\n"
"/*    FRAGMENT SHADER    */\n"
"float4 main_fragment(in out_vertex VAR, uniform sampler2D decal : TEXUNIT0, uniform input IN, uniform sampler2D LUT : TEXUNIT1) : COLOR\n"
"{\n"
"	float3 w1  = mul(yuv, tex2D(decal, VAR.t1.xw).rgb);\n"
"	float3 w2  = mul(yuv, tex2D(decal, VAR.t1.yw).rgb);\n"
"	float3 w3  = mul(yuv, tex2D(decal, VAR.t1.zw).rgb);\n"
"\n"
"	float3 w4  = mul(yuv, tex2D(decal, VAR.t2.xw).rgb);\n"
"	float3 w5  = mul(yuv, tex2D(decal, VAR.t2.yw).rgb);\n"
"	float3 w6  = mul(yuv, tex2D(decal, VAR.t2.zw).rgb);\n"
"\n"
"	float3 w7  = mul(yuv, tex2D(decal, VAR.t3.xw).rgb);\n"
"	float3 w8  = mul(yuv, tex2D(decal, VAR.t3.yw).rgb);\n"
"	float3 w9  = mul(yuv, tex2D(decal, VAR.t3.zw).rgb);\n"
"\n"
"	bool3x3 pattern = bool3x3(diff(w5, w1), diff(w5, w2), diff(w5, w3),\n"
"	                          diff(w5, w4), false       , diff(w5, w6),\n"
"	                          diff(w5, w7), diff(w5, w8), diff(w5, w9));\n"
"	bool4 cross = bool4(diff(w4, w2), diff(w2, w6), diff(w8, w4), diff(w6, w8));\n"
"\n"
"	half2 index;\n"
"	index.x = dot(pattern[0], half3(1, 2, 4)) +\n"
"	          dot(pattern[1], half3(8, 0, 16)) +\n"
"	          dot(pattern[2], half3(32, 64, 128));\n"
"	index.y = dot(cross, half4(1, 2, 4, 8));\n"
"\n"
"	return float4(index / half2(255.0, 15.0), 0.0, 1.0);\n"
"}\n"
},
