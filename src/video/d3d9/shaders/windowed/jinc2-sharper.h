{
"#pragma parameter JINC2_WINDOW_SINC \"Window Sinc Param\" 0.39 0.0 1.0 0.01\n"
"#pragma parameter JINC2_SINC \"Sinc Param\" 0.9 0.0 1.0 0.01\n"
"#pragma parameter JINC2_AR_STRENGTH \"Anti-ringing Strength\" 0.8 0.0 1.0 0.1\n"
"#ifdef PARAMETER_UNIFORM\n"
"uniform float JINC2_WINDOW_SINC;\n"
"uniform float JINC2_SINC;\n"
"uniform float JINC2_AR_STRENGTH;\n"
"#else\n"
"#define JINC2_WINDOW_SINC 0.39\n"
"#define JINC2_SINC 0.9\n"
"#define JINC2_AR_STRENGTH 0.8\n"
"#endif\n"
"// END PARAMETERS //\n"
"\n"
"/* COMPATIBILITY\n"
"   - HLSL compilers\n"
"   - Cg   compilers\n"
"*/\n"
"\n"
"/*\n"
"   Hyllian's jinc windowed-jinc 2-lobe sharper with anti-ringing Shader\n"
"   \n"
"   Copyright (C) 2011-2014 Hyllian/Jararaca - sergiogdb@gmail.com\n"
"\n"
"   This program is free software; you can redistribute it and/or\n"
"   modify it under the terms of the GNU General Public License\n"
"   as published by the Free Software Foundation; either version 2\n"
"   of the License, or (at your option) any later version.\n"
"\n"
"   This program is distributed in the hope that it will be useful,\n"
"   but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"   GNU General Public License for more details.\n"
"\n"
"   You should have received a copy of the GNU General Public License\n"
"   along with this program; if not, write to the Free Software\n"
"   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n"
"\n"
"*/\n"
"\n"
"      /*\n"
"         This is an approximation of Jinc(x)*Jinc(x*r1/r2) for x < 2.5,\n"
"         where r1 and r2 are the first two zeros of jinc function.\n"
"         For a jinc 2-lobe best approximation, use A=0.5 and B=0.825.\n"
"      */  \n"
"\n"
"// A=0.5, B=0.825 is the best jinc approximation for x<2.5. if B=1.0, it's a lanczos filter.\n"
"// Increase A to get more blur. Decrease it to get a sharper picture. \n"
"// B = 0.825 to get rid of dithering. Increase B to get a fine sharpness, though dithering returns.\n"
"\n"
"#define halfpi  1.5707963267948966192313216916398\n"
"#define pi    3.1415926535897932384626433832795\n"
"#define wa    (JINC2_WINDOW_SINC*pi)\n"
"#define wb    (JINC2_SINC*pi)\n"
"\n"
"// Calculates the distance between two points\n"
"float d(float2 pt1, float2 pt2)\n"
"{\n"
"  float2 v = pt2 - pt1;\n"
"  return sqrt(dot(v,v));\n"
"}\n"
"\n"
"float3 min4(float3 a, float3 b, float3 c, float3 d)\n"
"{\n"
"    return min(a, min(b, min(c, d)));\n"
"}\n"
"float3 max4(float3 a, float3 b, float3 c, float3 d)\n"
"{\n"
"    return max(a, max(b, max(c, d)));\n"
"}\n"
"\n"
"     \n"
"    struct input\n"
"    {\n"
"        float2 video_size;\n"
"        float2 texture_size;\n"
"        float2 output_size;\n"
"            float  frame_count;\n"
"            float  frame_direction;\n"
"        float frame_rotation;\n"
"    };\n"
"     \n"
"     \n"
"    struct out_vertex {\n"
"        float4 position : POSITION;\n"
"        float4 color    : COLOR;\n"
"        float2 texCoord : TEXCOORD0;\n"
"    };\n"
"     \n"
"    /*    VERTEX_SHADER    */\n"
"    out_vertex main_vertex\n"
"    (\n"
"        float4 position    : POSITION,\n"
"        float4 color    : COLOR,\n"
"        float2 texCoord1   : TEXCOORD0,\n"
"     \n"
"           uniform float4x4 modelViewProj,\n"
"        uniform input IN\n"
"    )\n"
"    {\n"
"\n"
"	// This line fix a bug in ATI cards.\n"
"	float2 tex = texCoord1;\n"
"\n"
"        out_vertex OUT = {\n"
"            mul(modelViewProj, position),\n"
"            color,\n"
"            tex\n"
"        };\n"
"     \n"
"        return OUT;\n"
"    }\n"
"     \n"
"    float4 resampler(float4 x)\n"
"    {\n"
"      float4 res;\n"
"\n"
"      res = (x==float4(0.0, 0.0, 0.0, 0.0)) ?  float4(wa*wb)  :  sin(x*wa)*sin(x*wb)/(x*x);\n"
"\n"
"      return res;\n"
"    }\n"
"     \n"
"    float4 main_fragment(in out_vertex VAR, uniform sampler2D s_p : TEXUNIT0, uniform input IN) : COLOR\n"
"    {\n"
"      float3 color;\n"
"      float4x4 weights;\n"
"\n"
"      float2 dx = float2(1.0, 0.0);\n"
"      float2 dy = float2(0.0, 1.0);\n"
"\n"
"      float2 pc = VAR.texCoord*IN.texture_size;\n"
"\n"
"      float2 tc = (floor(pc-float2(0.5,0.5))+float2(0.5,0.5));\n"
"     \n"
"      weights[0] = resampler(float4(d(pc, tc    -dx    -dy), d(pc, tc           -dy), d(pc, tc    +dx    -dy), d(pc, tc+2.0*dx    -dy)));\n"
"      weights[1] = resampler(float4(d(pc, tc    -dx       ), d(pc, tc              ), d(pc, tc    +dx       ), d(pc, tc+2.0*dx       )));\n"
"      weights[2] = resampler(float4(d(pc, tc    -dx    +dy), d(pc, tc           +dy), d(pc, tc    +dx    +dy), d(pc, tc+2.0*dx    +dy)));\n"
"      weights[3] = resampler(float4(d(pc, tc    -dx+2.0*dy), d(pc, tc       +2.0*dy), d(pc, tc    +dx+2.0*dy), d(pc, tc+2.0*dx+2.0*dy)));\n"
"\n"
"      dx = dx/IN.texture_size;\n"
"      dy = dy/IN.texture_size;\n"
"      tc = tc/IN.texture_size;\n"
"     \n"
"     // reading the texels\n"
"     \n"
"      float3 c00 = tex2D(s_p, tc    -dx    -dy).xyz;\n"
"      float3 c10 = tex2D(s_p, tc           -dy).xyz;\n"
"      float3 c20 = tex2D(s_p, tc    +dx    -dy).xyz;\n"
"      float3 c30 = tex2D(s_p, tc+2.0*dx    -dy).xyz;\n"
"      float3 c01 = tex2D(s_p, tc    -dx       ).xyz;\n"
"      float3 c11 = tex2D(s_p, tc              ).xyz;\n"
"      float3 c21 = tex2D(s_p, tc    +dx       ).xyz;\n"
"      float3 c31 = tex2D(s_p, tc+2.0*dx       ).xyz;\n"
"      float3 c02 = tex2D(s_p, tc    -dx    +dy).xyz;\n"
"      float3 c12 = tex2D(s_p, tc           +dy).xyz;\n"
"      float3 c22 = tex2D(s_p, tc    +dx    +dy).xyz;\n"
"      float3 c32 = tex2D(s_p, tc+2.0*dx    +dy).xyz;\n"
"      float3 c03 = tex2D(s_p, tc    -dx+2.0*dy).xyz;\n"
"      float3 c13 = tex2D(s_p, tc       +2.0*dy).xyz;\n"
"      float3 c23 = tex2D(s_p, tc    +dx+2.0*dy).xyz;\n"
"      float3 c33 = tex2D(s_p, tc+2.0*dx+2.0*dy).xyz;\n"
"\n"
"      //  Get min/max samples\n"
"      float3 min_sample = min4(c11, c21, c12, c22);\n"
"      float3 max_sample = max4(c11, c21, c12, c22);\n"
"\n"
"      color = mul(weights[0], float4x3(c00, c10, c20, c30));\n"
"      color+= mul(weights[1], float4x3(c01, c11, c21, c31));\n"
"      color+= mul(weights[2], float4x3(c02, c12, c22, c32));\n"
"      color+= mul(weights[3], float4x3(c03, c13, c23, c33));\n"
"      color = color/(dot(mul(weights, float4(1)), 1));\n"
"\n"
"      // Anti-ringing\n"
"      float3 aux = color;\n"
"      color = clamp(color, min_sample, max_sample);\n"
"\n"
"      color = lerp(aux, color, JINC2_AR_STRENGTH);\n"
" \n"
"      // final sum and weight normalization\n"
"      return float4(color, 1);\n"
"     \n"
"    }\n"
"\n"
"\n"
},
