{
"/*\n"
"   Hyllian's xBR LV2 C (squared) - pass0 Shader\n"
"   \n"
"   Copyright (C) 2011-2015 Hyllian - sergiogdb@gmail.com\n"
"\n"
"   Permission is hereby granted, free of charge, to any person obtaining a copy\n"
"   of this software and associated documentation files (the \"Software\"), to deal\n"
"   in the Software without restriction, including without limitation the rights\n"
"   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n"
"   copies of the Software, and to permit persons to whom the Software is\n"
"   furnished to do so, subject to the following conditions:\n"
"\n"
"   The above copyright notice and this permission notice shall be included in\n"
"   all copies or substantial portions of the Software.\n"
"\n"
"   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n"
"   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n"
"   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n"
"   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n"
"   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n"
"   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n"
"   THE SOFTWARE.\n"
"\n"
"\n"
"   Incorporates some of the ideas from SABR shader. Thanks to Joshua Street.\n"
"*/\n"
"\n"
"const static float coef            = 2.0;\n"
"const static float4 eq_threshold   = float4(15.0, 15.0, 15.0, 15.0);\n"
"const static float y_weight        = 48.0;\n"
"const static float u_weight        = 7.0;\n"
"const static float v_weight        = 6.0;\n"
"const static float3x3 yuv          = float3x3(0.299, 0.587, 0.114, -0.169, -0.331, 0.499, 0.499, -0.418, -0.0813);\n"
"const static float3x3 yuv_weighted = float3x3(y_weight*yuv[0], u_weight*yuv[1], v_weight*yuv[2]);\n"
"const static float4 delta          = float4(0.4, 0.4, 0.4, 0.4);\n"
"\n"
"\n"
"float3 remapTo01(float3 v, float3 low, float3 high)\n"
"{\n"
"	return saturate((v - low)/(high-low));\n"
"}\n"
"\n"
"\n"
"float4 df(float4 A, float4 B)\n"
"{\n"
"	return float4(abs(A-B));\n"
"}\n"
"\n"
"float c_df(float3 c1, float3 c2)\n"
"{\n"
"	float3 df = abs(c1 - c2);\n"
"	return df.r + df.g + df.b;\n"
"}\n"
"\n"
"\n"
"bool4 eq(float4 A, float4 B)\n"
"{\n"
"	return (df(A, B) < eq_threshold);\n"
"}\n"
"\n"
"float4 weighted_distance(float4 a, float4 b, float4 c, float4 d, float4 e, float4 f, float4 g, float4 h)\n"
"{\n"
"	return (df(a,b) + df(a,c) + df(d,e) + df(d,f) + 4.0*df(g,h));\n"
"}\n"
"\n"
"\n"
"\n"
"struct input\n"
"{\n"
"	float2 video_size;\n"
"	float2 texture_size;\n"
"	float2 output_size;\n"
"	float frame_count;\n"
"	float frame_direction;\n"
"	float frame_rotation;\n"
"};\n"
"\n"
"\n"
"struct out_vertex {\n"
"	float4 position : POSITION;\n"
"	float4 color    : COLOR;\n"
"	float2 texCoord : TEXCOORD0;\n"
"	float4 t1       : TEXCOORD1;\n"
"	float4 t2       : TEXCOORD2;\n"
"	float4 t3       : TEXCOORD3;\n"
"	float4 t4       : TEXCOORD4;\n"
"	float4 t5       : TEXCOORD5;\n"
"	float4 t6       : TEXCOORD6;\n"
"	float4 t7       : TEXCOORD7;\n"
"};\n"
"\n"
"/*    VERTEX_SHADER    */\n"
"out_vertex main_vertex\n"
"(\n"
"	float4 position	: POSITION,\n"
"	float4 color	: COLOR,\n"
"	float2 texCoord : TEXCOORD0,\n"
"\n"
"   	uniform float4x4 modelViewProj,\n"
"	uniform input IN\n"
")\n"
"{\n"
"	out_vertex OUT;\n"
"\n"
"	OUT.position = mul(modelViewProj, position);\n"
"	OUT.color = color;\n"
"\n"
"	float2 ps = float2(1.0/IN.texture_size.x, 1.0/IN.texture_size.y);\n"
"	float dx = ps.x;\n"
"	float dy = ps.y;\n"
"\n"
"	//    A1 B1 C1\n"
"	// A0  A  B  C C4\n"
"	// D0  D  E  F F4\n"
"	// G0  G  H  I I4\n"
"	//    G5 H5 I5\n"
"\n"
"	OUT.texCoord = texCoord;\n"
"	OUT.t1 = texCoord.xxxy + float4( -dx, 0, dx,-2.0*dy); // A1 B1 C1\n"
"	OUT.t2 = texCoord.xxxy + float4( -dx, 0, dx,    -dy); //  A  B  C\n"
"	OUT.t3 = texCoord.xxxy + float4( -dx, 0, dx,      0); //  D  E  F\n"
"	OUT.t4 = texCoord.xxxy + float4( -dx, 0, dx,     dy); //  G  H  I\n"
"	OUT.t5 = texCoord.xxxy + float4( -dx, 0, dx, 2.0*dy); // G5 H5 I5\n"
"	OUT.t6 = texCoord.xyyy + float4(-2.0*dx,-dy, 0,  dy); // A0 D0 G0\n"
"	OUT.t7 = texCoord.xyyy + float4( 2.0*dx,-dy, 0,  dy); // C4 F4 I4\n"
"\n"
"	return OUT;\n"
"}\n"
"\n"
"\n"
"/*    FRAGMENT SHADER    */\n"
"float4 main_fragment(in out_vertex VAR, uniform sampler2D decal : TEXUNIT0, uniform input IN) : COLOR\n"
"{\n"
"	bool4 edr, edr_left, edr_up; \n"
"	bool4 interp_restriction_lv1, interp_restriction_lv2_left, interp_restriction_lv2_up;\n"
"\n"
"	float3 A1 = tex2D(decal, VAR.t1.xw).rgb;\n"
"	float3 B1 = tex2D(decal, VAR.t1.yw).rgb;\n"
"	float3 C1 = tex2D(decal, VAR.t1.zw).rgb;\n"
"\n"
"	float3 A  = tex2D(decal, VAR.t2.xw).rgb;\n"
"	float3 B  = tex2D(decal, VAR.t2.yw).rgb;\n"
"	float3 C  = tex2D(decal, VAR.t2.zw).rgb;\n"
"\n"
"	float3 D  = tex2D(decal, VAR.t3.xw).rgb;\n"
"	float3 E  = tex2D(decal, VAR.t3.yw).rgb;\n"
"	float3 F  = tex2D(decal, VAR.t3.zw).rgb;\n"
"\n"
"	float3 G  = tex2D(decal, VAR.t4.xw).rgb;\n"
"	float3 H  = tex2D(decal, VAR.t4.yw).rgb;\n"
"	float3 I  = tex2D(decal, VAR.t4.zw).rgb;\n"
"\n"
"	float3 G5 = tex2D(decal, VAR.t5.xw).rgb;\n"
"	float3 H5 = tex2D(decal, VAR.t5.yw).rgb;\n"
"	float3 I5 = tex2D(decal, VAR.t5.zw).rgb;\n"
"\n"
"	float3 A0 = tex2D(decal, VAR.t6.xy).rgb;\n"
"	float3 D0 = tex2D(decal, VAR.t6.xz).rgb;\n"
"	float3 G0 = tex2D(decal, VAR.t6.xw).rgb;\n"
"\n"
"	float3 C4 = tex2D(decal, VAR.t7.xy).rgb;\n"
"	float3 F4 = tex2D(decal, VAR.t7.xz).rgb;\n"
"	float3 I4 = tex2D(decal, VAR.t7.xw).rgb;\n"
"\n"
"	float4 b = mul( float4x3(B, D, H, F), yuv_weighted[0] );\n"
"	float4 c = mul( float4x3(C, A, G, I), yuv_weighted[0] );\n"
"	float4 e = mul( float4x3(E, E, E, E), yuv_weighted[0] );\n"
"	float4 d = b.yzwx;\n"
"	float4 f = b.wxyz;\n"
"	float4 g = c.zwxy;\n"
"	float4 h = b.zwxy;\n"
"	float4 i = c.wxyz;\n"
"\n"
"	float4 i4 = mul( float4x3(I4, C1, A0, G5), yuv_weighted[0] );\n"
"	float4 i5 = mul( float4x3(I5, C4, A1, G0), yuv_weighted[0] );\n"
"	float4 h5 = mul( float4x3(H5, F4, B1, D0), yuv_weighted[0] );\n"
"	float4 f4 = h5.yzwx;\n"
"\n"
"	interp_restriction_lv1      = ((e!=f) && (e!=h)  && ( !eq(f,b) && !eq(f,c) || !eq(h,d) && !eq(h,g) || eq(e,i) && (!eq(f,f4) && !eq(f,i4) || !eq(h,h5) && !eq(h,i5)) || eq(e,g) || eq(e,c)) );\n"
"	interp_restriction_lv2_left = ((e!=g) && (d!=g));\n"
"	interp_restriction_lv2_up   = ((e!=c) && (b!=c));\n"
"\n"
"	edr      = (weighted_distance( e, c, g, i, h5, f4, h, f) < weighted_distance( h, d, i5, f, i4, b, e, i)) && interp_restriction_lv1;\n"
"	edr_left = ((coef*df(f,g)) <= df(h,c)) && interp_restriction_lv2_left && edr;\n"
"	edr_up   = (df(f,g) >= (coef*df(h,c))) && interp_restriction_lv2_up   && edr;\n"
"\n"
"	float3 info;\n"
"\n"
"	info.x = dot(float4(edr     ), float4(8.0f, 4.0f, 2.0f, 1.0f));\n"
"	info.y = dot(float4(edr_left), float4(8.0f, 4.0f, 2.0f, 1.0f));\n"
"	info.z = dot(float4(edr_up  ), float4(8.0f, 4.0f, 2.0f, 1.0f));\n"
"\n"
"	return float4(remapTo01(info, float3(0.0f, 0.0f, 0.0f), float3(255.0f, 255.0f, 255.0f)), 1.0);\n"
"}\n"
},
