{
"/*\n"
"   Hyllian's xBR LV2 - pass1 Shader\n"
"   \n"
"   Copyright (C) 2011-2015 Hyllian - sergiogdb@gmail.com\n"
"\n"
"   Permission is hereby granted, free of charge, to any person obtaining a copy\n"
"   of this software and associated documentation files (the \"Software\"), to deal\n"
"   in the Software without restriction, including without limitation the rights\n"
"   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n"
"   copies of the Software, and to permit persons to whom the Software is\n"
"   furnished to do so, subject to the following conditions:\n"
"\n"
"   The above copyright notice and this permission notice shall be included in\n"
"   all copies or substantial portions of the Software.\n"
"\n"
"   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n"
"   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n"
"   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n"
"   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n"
"   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n"
"   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n"
"   THE SOFTWARE.\n"
"\n"
"\n"
"   Incorporates some of the ideas from SABR shader. Thanks to Joshua Street.\n"
"*/\n"
"\n"
"#define round(X) floor((X)+0.5)\n"
"\n"
"const static float coef           = 2.0;\n"
"const static float4 eq_threshold  = float4(15.0, 15.0, 15.0, 15.0);\n"
"const static float y_weight        = 48.0;\n"
"const static float u_weight        = 7.0;\n"
"const static float v_weight        = 6.0;\n"
"const static float3x3 yuv          = float3x3(0.299, 0.587, 0.114, -0.169, -0.331, 0.499, 0.499, -0.418, -0.0813);\n"
"const static float3x3 yuv_weighted = float3x3(y_weight*yuv[0], u_weight*yuv[1], v_weight*yuv[2]);\n"
"\n"
"\n"
"float4 df(float4 A, float4 B)\n"
"{\n"
"	return float4(abs(A-B));\n"
"}\n"
"\n"
"float c_df(float3 c1, float3 c2)\n"
"{\n"
"	float3 df = abs(c1 - c2);\n"
"	return df.r + df.g + df.b;\n"
"}\n"
"\n"
"bool4 eq(float4 A, float4 B)\n"
"{\n"
"	return (df(A, B) < eq_threshold);\n"
"}\n"
"\n"
"float4 weighted_distance(float4 a, float4 b, float4 c, float4 d, float4 e, float4 f, float4 g, float4 h)\n"
"{\n"
"	return (df(a,b) + df(a,c) + df(d,e) + df(d,f) + 4.0*df(g,h));\n"
"}\n"
"\n"
"\n"
"float3 remapFrom01(float3 v, float3 low, float3 high)\n"
"{\n"
"	return round(lerp(low, high, v));\n"
"}\n"
"\n"
"float4 unpack_info(float i)\n"
"{\n"
"	float4 info;\n"
"	info.w = round(modf(i/2.0f, i));\n"
"	info.z = round(modf(i/2.0f, i));\n"
"	info.y = round(modf(i/2.0f, i));\n"
"	info.x = i;\n"
"\n"
"	return info;\n"
"}\n"
"\n"
"struct orig\n"
"{\n"
"	float2 tex_coord;\n"
"	uniform float2 texture_size;\n"
"	uniform sampler2D texture;\n"
"};\n"
"\n"
"\n"
"struct input\n"
"{\n"
"	float2 video_size;\n"
"	float2 texture_size;\n"
"	float2 output_size;\n"
"	float frame_count;\n"
"	float frame_direction;\n"
"	float frame_rotation;\n"
"};\n"
"\n"
"struct out_vertex {\n"
"	float4 position : POSITION;\n"
"	float4 color    : COLOR;\n"
"	float2 texCoord : TEXCOORD0;\n"
"	float4 t1       : TEXCOORD1;\n"
"	float4 t2       : TEXCOORD2;\n"
"	float4 t3       : TEXCOORD3;\n"
"	float2 orig_tex;\n"
"};\n"
"\n"
"/*    VERTEX_SHADER    */\n"
"void main_vertex\n"
"(\n"
"	float4 position	: POSITION,\n"
"	float4 color	: COLOR,\n"
"	float2 texCoord : TEXCOORD0,\n"
"\n"
"   	uniform float4x4 modelViewProj,\n"
"	orig ORIG,\n"
"	out out_vertex co\n"
")\n"
"{\n"
"	co.position = mul(modelViewProj, position);\n"
"	co.color = color;\n"
"\n"
"	float2 ps = float2(1.0/ORIG.texture_size.x, 1.0/ORIG.texture_size.y);\n"
"	float dx = ps.x;\n"
"	float dy = ps.y;\n"
"\n"
"	//    A1 B1 C1\n"
"	// A0  A  B  C C4\n"
"	// D0  D  E  F F4\n"
"	// G0  G  H  I I4\n"
"	//    G5 H5 I5\n"
"\n"
"	co.texCoord = texCoord;\n"
"	co.orig_tex = ORIG.tex_coord;\n"
"	co.t1 = ORIG.tex_coord.xyyy + float4(   0, -dy,  0, dy);  //  B\n"
"	co.t2 = ORIG.tex_coord.xxxy + float4( -dx,   0, dx,  0);  //D E F\n"
"                                                                  //  H\n"
"}\n"
"\n"
"\n"
"/*    FRAGMENT SHADER    */\n"
"float4 main_fragment(in out_vertex co, uniform sampler2D decal : TEXUNIT0, orig ORIG, uniform input IN) : COLOR\n"
"{\n"
"\n"
"	bool4 px; // px = pixel, edr = edge detection rule\n"
"	float4 edr, edr_left, edr_up;\n"
"	float4 fx, fx_left, fx_up, final_fx; // inequations of straight lines.\n"
"	float3 res1, res2, pix1, pix2;\n"
"	float blend1, blend2;\n"
"\n"
"	float2 fp = frac(co.texCoord*IN.texture_size);\n"
"\n"
"\n"
"	float3 B  = tex2D(ORIG.texture, co.t1.xy).rgb;\n"
"	float3 D  = tex2D(ORIG.texture, co.t2.xw).rgb;\n"
"	float3 E  = tex2D(ORIG.texture, co.t2.yw).rgb;\n"
"	float3 F  = tex2D(ORIG.texture, co.t2.zw).rgb;\n"
"	float3 H  = tex2D(ORIG.texture, co.t1.xw).rgb;\n"
"\n"
"\n"
"	float4 b = mul( float4x3(B, D, H, F), yuv_weighted[0] );\n"
"	float4 e = mul( float4x3(E, E, E, E), yuv_weighted[0] );\n"
"	float4 d = b.yzwx;\n"
"	float4 f = b.wxyz;\n"
"	float4 h = b.zwxy;\n"
"\n"
"	float4 Ao = float4( 1.0, -1.0, -1.0, 1.0 );\n"
"	float4 Bo = float4( 1.0,  1.0, -1.0,-1.0 );\n"
"	float4 Co = float4( 1.5,  0.5, -0.5, 0.5 );\n"
"	float4 Ax = float4( 1.0, -1.0, -1.0, 1.0 );\n"
"	float4 Bx = float4( 0.5,  2.0, -0.5,-2.0 );\n"
"	float4 Cx = float4( 1.0,  1.0, -0.5, 0.0 );\n"
"	float4 Ay = float4( 1.0, -1.0, -1.0, 1.0 );\n"
"	float4 By = float4( 2.0,  0.5, -2.0,-0.5 );\n"
"	float4 Cy = float4( 2.0,  0.0, -1.0, 0.5 );\n"
"\n"
"	// These inequations define the line below which interpolation occurs.\n"
"	fx      = (Ao*fp.y+Bo*fp.x); \n"
"	fx_left = (Ax*fp.y+Bx*fp.x);\n"
"	fx_up   = (Ay*fp.y+By*fp.x);\n"
"\n"
"        float2 delta = float2(IN.video_size.x/IN.output_size.x, 0.5*IN.video_size.x/IN.output_size.x);\n"
"\n"
"	float4 fx45 = saturate((fx      + delta.xxxx -Co)/(2*delta.xxxx));\n"
"	float4 fx30 = saturate((fx_left + delta.yxyx -Cx)/(2*delta.yxyx));\n"
"	float4 fx60 = saturate((fx_up   + delta.xyxy -Cy)/(2*delta.xyxy));\n"
"\n"
"	float4 info  = tex2D(decal, co.texCoord);\n"
"\n"
"	float3 i = remapFrom01(info.xyz, float3(0.0f, 0.0f, 0.0f), float3(255.0f, 255.0f, 255.0f));\n"
"\n"
"	edr      = unpack_info(i.x);\n"
"	edr_left = unpack_info(i.y);\n"
"	edr_up   = unpack_info(i.z);\n"
"\n"
"	fx45 = edr*fx45;\n"
"	fx30 = edr_left*fx30;\n"
"	fx60 = edr_up*fx60;\n"
"\n"
"	px = (df(e,f) <= df(e,h));\n"
"\n"
"	float4 maximo = max(max(fx30, fx60), fx45);\n"
"\n"
"        float4x3 pix = float4x3(lerp(E, lerp(H, F, px.x), maximo.x), lerp(E, lerp(F, B, px.y), maximo.y), lerp(E, lerp(B, D, px.z), maximo.z), lerp(E, lerp(D, H, px.w), maximo.w));\n"
"	float4 pixel = mul( pix, yuv_weighted[0] );\n"
"	\n"
"\n"
"	float4 diff = df(pixel,e);\n"
"\n"
"	float3 res = pix[0];\n"
"	float mx = diff.x;\n"
"\n"
"        if (diff.y > mx) {res = pix[1]; mx = diff.y;}\n"
"        if (diff.z > mx) {res = pix[2]; mx = diff.z;}\n"
"        if (diff.w > mx) {res = pix[3];}\n"
"\n"
"\n"
"	return float4(res, 1.0);\n"
"}\n"
"\n"
"\n"
},
